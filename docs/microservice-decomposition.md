# План декомпозиции монолитного чат-приложения

## Пользовательские сценарии
1. **Регистрация**: новый пользователь регистрируется по имени и получает bearer-токен.
2. **Отправка сообщения**: авторизованный пользователь отправляет сообщение другому пользователю, опционально отвечая на существующее сообщение.
3. **Чтение диалога**: авторизованный пользователь получает историю переписки с собеседником с пагинацией.
4. **Уведомление адресата**: после доставки сообщения получатель получает push/webhook-уведомление.

## Выбранная стратегия декомпозиции
- **По бизнес-возможностям**: профиль/идентификация, аутентификация, обмен сообщениями, уведомления.
- **Выделение общих инфраструктурных компетенций**: API Gateway, сквозной трекинг запросов, централизованные логи и метрики.

## Сервисы и зоны ответственности
- **API Gateway (legacy monolith facade)**: принимает внешние запросы, валидирует схемы, проксирует в бэкенды, завершает TLS, прокидывает `x-request-id` и консолидирует ответы/ошибки.
- **Identity Service**: управление пользователями (создание, чтение профиля), хранилище идентификаторов, валидация уникальности имени.
- **Auth Service**: выдача и валидация bearer-токенов, политика TTL, отзыв/чёрные списки; проверяет подпись и публикует результат авторизации.
- **Chat Service**: приём и хранение сообщений, построение списков сообщений для пары пользователей, ссылки на ответ (`reply_to`), аудит цепочки `x-request-id`.
- **Notification Service**: получение событий о новых сообщениях и доставка push/webhook/SMS с backoff/повторами.
- **Observability (лог/метрики)**: приём структурированных логов и метрик от всех сервисов, корреляция по `x-request-id`.

## Контракты и взаимодействия
### Синхронные REST/HTTP
- `POST /api/v1/user/register` (Gateway → Identity) → `{ user: { id, name }, token }` (Gateway запрашивает токен в Auth после создания пользователя).
- `GET /api/v1/user/{id}` (Gateway → Identity) → `{ id, name, created_at }`.
- `POST /api/v1/dialog/{user_id}/send` (Gateway → Auth for token validation → Chat) тело `{ text, reply_to? }` → `{ id, from, to, text, reply_to, ts }`.
- `GET /api/v1/dialog/{user_id}/list?cursor&limit` (Gateway → Auth → Chat) → `{ total, items: [...] }`.

### Асинхронные события (Kafka/RabbitMQ)
- **auth.validated**: Auth → Gateway (для кэширования результата в рамках запроса).
- **chat.message_created**: Chat → Notification/Observability, payload `{ message_id, to_user_id, x_request_id, ts }`.
- **notification.delivered / notification.failed**: Notification → Observability.

### Общие требования к контрактам
- Каждое сообщение/запрос должно содержать `x-request-id` и идентификатор инициатора (subject) от Auth.
- Формат ошибок: `{ code, message, details? }` с таблицей кодов, общей для всех сервисов.
- Версионирование REST путём `/api/v{n}` и версионирование событий через `type` и `schema_version`.

## Схема взаимодействия
См. диаграмму PlantUML в `docs/microservice-decomposition.puml`.

## Топология данных
- Identity хранит пользователей в реляционной БД (PostgreSQL) с уникальным индексом по `name`.
- Auth хранит ключи подписи токенов (JWKS) и чёрные списки в Redis/PostgreSQL.
- Chat хранит сообщения в базе, оптимизированной под временную сортировку (PostgreSQL/Timescale), с индексами по (from, to, ts) и `reply_to`.
- Notification использует брокер для очередей доставки и хранит состояние попыток в собственной БД.

## Нефункциональные требования
- **Надёжность**: идемпотентные хендлеры в Chat/Notification, повторная обработка событий, дедупликация по `message_id`.
- **Безопасность**: все внешние вызовы идут через Gateway; межсервисные вызовы — mTLS; принципы наименьших привилегий для токенов сервисов.
- **Наблюдаемость**: структурированные логи и метрики в каждую операцию; трейсинг по `x-request-id` и span-id.
- **Эволюция**: возможность добавлять новые типы сообщений (файлы/реакции) через новые версии контрактов без изменений существующих клиентов.

## Как разделить монолит на микросервисы
Чтобы из «толстого» монолита получить отдельные сервисы из списка выше, придерживайтесь следующих шагов:

1. **Инвентаризация кода**: зафиксируйте модули/пакеты монолита и сопоставьте их будущим сервисам:
   - `users` → **Identity** (CRUD по пользователям),
   - `auth` → **Auth** (JWKS, подпись/проверка токенов),
   - `chat/messages` → **Chat** (хранение, выборки, идемпотентность),
   - `notifications` → **Notification** (каналы доставки, ретраи),
   - HTTP-контроллеры → **API Gateway** (валидация схем и прокси на бэкенды).

2. **Выделение фасада (strangler)**: оставьте существующие HTTP-роуты в монолите, но заверните их в **Gateway**, который сначала проксирует в старый код. По мере выноса логики, маршруты внутри фасада переключаются на новые сервисы без изменения публичных URL.

3. **Стабилизация контрактов**: зафиксируйте REST и событийнные схемы из раздела «Контракты и взаимодействия», добавьте в репозиторий shared-schema (OpenAPI + Avro/JSON Schema) и автоматическую валидацию в CI.

4. **Экстракция по сервисам (итеративно)**:
   - **Identity**: вынесите модели/репозитории пользователей, поднимите отдельную БД, добавьте адаптер в Gateway (`/user/*`).
   - **Auth**: вынесите генерацию/проверку токенов и JWKS; Gateway начинает дергать Auth для валидации перед Chat/Identity.
   - **Chat**: перенесите запись и чтение сообщений, добавьте публикацию `chat.message_created` в шину событий.
   - **Notification**: подписка на `chat.message_created`, реализация каналов доставки и статусных событий.

5. **Данные и миграции**: для каждого шага добавляйте двоичную запись (dual writes) из монолита в новую БД, затем переключайте чтения на новый сервис. После стабилизации отключайте старые таблицы.

6. **Наблюдаемость и SLO**: подключите централизованный логинг/метрики с единым `x-request-id`, определите SLO на ключевые сценарии (регистрация, отправка, чтение) и автоматизируйте алерты.

7. **Удаление остаточного кода**: когда маршруты полностью обслуживаются новыми сервисами, удалите дублирующий код из монолита, оставив Gateway как стабильный вход.

Такой порядок позволяет минимизировать риски: сначала вводится стабильный фасад и схемы, затем послойно выносятся функции с контролируемыми миграциями данных и сохранением существующих пользовательских URL.

