# План декомпозиции монолитного чат-приложения

## Пользовательские сценарии
1. **Регистрация**: новый пользователь регистрируется по имени и получает bearer-токен.
2. **Отправка сообщения**: авторизованный пользователь отправляет сообщение другому пользователю, опционально отвечая на существующее сообщение.
3. **Чтение диалога**: авторизованный пользователь получает историю переписки с собеседником с пагинацией.
4. **Уведомление адресата**: после доставки сообщения получатель получает push/webhook-уведомление.

## Выбранная стратегия декомпозиции
- **По бизнес-возможностям**: профиль/идентификация, аутентификация, обмен сообщениями, уведомления.
- **Выделение общих инфраструктурных компетенций**: API Gateway, сквозной трекинг запросов, централизованные логи и метрики.

## Сервисы и зоны ответственности
- **API Gateway (legacy monolith facade)**: принимает внешние запросы, валидирует схемы, проксирует в бэкенды, завершает TLS, прокидывает `x-request-id` и консолидирует ответы/ошибки.
- **Identity Service**: управление пользователями (создание, чтение профиля), хранилище идентификаторов, валидация уникальности имени.
- **Auth Service**: выдача и валидация bearer-токенов, политика TTL, отзыв/чёрные списки; проверяет подпись и публикует результат авторизации.
- **Chat Service**: приём и хранение сообщений, построение списков сообщений для пары пользователей, ссылки на ответ (`reply_to`), аудит цепочки `x-request-id`.
- **Notification Service**: получение событий о новых сообщениях и доставка push/webhook/SMS с backoff/повторами.
- **Observability (лог/метрики)**: приём структурированных логов и метрик от всех сервисов, корреляция по `x-request-id`.

## Контракты и взаимодействия
### Синхронные REST/HTTP
- `POST /api/v1/user/register` (Gateway → Identity) → `{ user: { id, name }, token }` (Gateway запрашивает токен в Auth после создания пользователя).
- `GET /api/v1/user/{id}` (Gateway → Identity) → `{ id, name, created_at }`.
- `POST /api/v1/dialog/{user_id}/send` (Gateway → Auth for token validation → Chat) тело `{ text, reply_to? }` → `{ id, from, to, text, reply_to, ts }`.
- `GET /api/v1/dialog/{user_id}/list?cursor&limit` (Gateway → Auth → Chat) → `{ total, items: [...] }`.

### Асинхронные события (Kafka/RabbitMQ)
- **auth.validated**: Auth → Gateway (для кэширования результата в рамках запроса).
- **chat.message_created**: Chat → Notification/Observability, payload `{ message_id, to_user_id, x_request_id, ts }`.
- **notification.delivered / notification.failed**: Notification → Observability.

### Общие требования к контрактам
- Каждое сообщение/запрос должно содержать `x-request-id` и идентификатор инициатора (subject) от Auth.
- Формат ошибок: `{ code, message, details? }` с таблицей кодов, общей для всех сервисов.
- Версионирование REST путём `/api/v{n}` и версионирование событий через `type` и `schema_version`.

## Схема взаимодействия
См. диаграмму PlantUML в `docs/microservice-decomposition.puml`.

## Топология данных
- Identity хранит пользователей в реляционной БД (PostgreSQL) с уникальным индексом по `name`.
- Auth хранит ключи подписи токенов (JWKS) и чёрные списки в Redis/PostgreSQL.
- Chat хранит сообщения в базе, оптимизированной под временную сортировку (PostgreSQL/Timescale), с индексами по (from, to, ts) и `reply_to`.
- Notification использует брокер для очередей доставки и хранит состояние попыток в собственной БД.

## Нефункциональные требования
- **Надёжность**: идемпотентные хендлеры в Chat/Notification, повторная обработка событий, дедупликация по `message_id`.
- **Безопасность**: все внешние вызовы идут через Gateway; межсервисные вызовы — mTLS; принципы наименьших привилегий для токенов сервисов.
- **Наблюдаемость**: структурированные логи и метрики в каждую операцию; трейсинг по `x-request-id` и span-id.
- **Эволюция**: возможность добавлять новые типы сообщений (файлы/реакции) через новые версии контрактов без изменений существующих клиентов.
